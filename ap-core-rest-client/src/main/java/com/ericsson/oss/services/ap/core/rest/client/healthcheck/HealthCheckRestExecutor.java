/*------------------------------------------------------------------------------
 *******************************************************************************
 * COPYRIGHT Ericsson 2020
 *
 * The copyright to the computer program(s) herein is the property of
 * Ericsson Inc. The programs may be used and/or copied only with written
 * permission from Ericsson Inc. or in accordance with the terms and
 * conditions stipulated in the agreement/contract under which the
 * program(s) have been supplied.
 *******************************************************************************
 *----------------------------------------------------------------------------*/
package com.ericsson.oss.services.ap.core.rest.client.healthcheck;

import static com.ericsson.oss.services.ap.core.rest.client.RestUrls.NHC_PROFILE_SERVICE;
import static com.ericsson.oss.services.ap.core.rest.client.RestUrls.NHC_SERVICE;

import java.io.IOException;
import java.net.URISyntaxException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.TimeUnit;

import javax.ejb.TransactionAttribute;
import javax.ejb.TransactionAttributeType;
import javax.inject.Inject;

import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.entity.EntityBuilder;
import org.apache.http.client.methods.HttpDelete;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.entity.ContentType;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClientBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ericsson.oss.itpf.sdk.core.retry.RetryManager;
import com.ericsson.oss.itpf.sdk.core.retry.RetryPolicy;
import com.ericsson.oss.itpf.sdk.core.retry.classic.RetryManagerBean;
import com.ericsson.oss.itpf.sdk.security.accesscontrol.EAccessControl;
import com.ericsson.oss.services.ap.api.exception.HealthCheckRestServiceException;
import com.ericsson.oss.services.ap.core.rest.client.common.HttpConstants;
import com.ericsson.oss.services.ap.core.rest.client.healthcheck.model.CreateReportRequest;
import com.ericsson.oss.services.ap.core.rest.client.healthcheck.model.ProfileDetails;
import com.ericsson.oss.services.ap.core.rest.client.healthcheck.model.Report;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

/**
 * This class is responsible for building Rest requests to send to Node Health Check.
 */
@TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
public class HealthCheckRestExecutor {

    private static final int MAX_RETRIES_VIEW_BY_NAME = 3;
    private static final int RETRY_INTERVAL_IN_SECONDS_VIEW_BY_NAME = 20;

    private static final int MAX_RETRIES_VIEW_BY_ID = 30;
    private static final int RETRY_INTERVAL_IN_SECONDS_VIEW_BY_ID = 30;

    private static final int MAX_RETRIES_CREATE = 3;
    private static final int RETRY_INTERVAL_CREATE = 3;

    private static final String IMMEDIATE = "IMMEDIATE";

    private static ObjectMapper objectMapper = new ObjectMapper();

    private final Logger logger = LoggerFactory.getLogger(HealthCheckRestExecutor.class);

    private final CloseableHttpClient httpClient;

    @Inject
    private HealthCheckResponseHandler responseHandler;

    @Inject
    private EAccessControl accessControl;

    public HealthCheckRestExecutor() {
        this.httpClient = HttpClientBuilder.create().build();
    }

    /**
     * Calls NHC interface to delete reports generated by AP nodes.
     *
     * @param deleteUrl
     *            the delete url containing reportIds as @PathParams
     * @throws ClientProtocolException
     *             Signals an error in the HTTP protocol.
     * @throws IOException
     *             Signals that an I/O exception of some sort has occurred.
     */
    public void deleteGeneratedReports(final String deleteUrl) throws ClientProtocolException, IOException {
        final HttpDelete deleteRequest = new HttpDelete(deleteUrl);
        deleteRequest.setHeader(HttpConstants.ACCEPT_HEADER, ContentType.APPLICATION_JSON.toString());
        deleteRequest.setHeader(HttpConstants.HOST, NHC_SERVICE.getHost());
        deleteRequest.setHeader(HttpConstants.USERNAME_HEADER, accessControl.getAuthUserSubject().getSubjectId());
        final HttpResponse response = httpClient.execute(deleteRequest);
        responseHandler.processDeleteReportResponse(response);
    }

    /**
     * Retrieves the name of the generated report from NHC.
     *
     * @param nodeName
     *            the name of AP node
     * @param profileName
     *            the name of the Health Check Profile
     * @return the name of the generated report
     * @throws ClientProtocolException
     * @throws IOException
     */
    public String getReportName(final String nodeName, final String profileName) throws ClientProtocolException, IOException {
        final RetryManager retryManager = new RetryManagerBean();
        final RetryPolicy retry = getRetryPolicy(MAX_RETRIES_CREATE, RETRY_INTERVAL_CREATE);
        final String reportName = retryManager.executeCommand(retry,
            retryContext -> {
                logger.info("Creating health check report for node {} using profile {} ", nodeName, profileName);
                return generateReport(nodeName, profileName);
            });
        return reportName;
    }

    /**
     * Retrieves the mainReportId of the {@link Report} generated by NHC.
     *
     * @param url
     *            The internal URL of NHC
     * @param reportName
     *            The name of the report
     * @return the ID of the generated report.
     */
    public String getMainReportId(final String url, final String reportName) {
        final RetryManager retryManager = new RetryManagerBean();
        final RetryPolicy retry = getRetryPolicy(MAX_RETRIES_VIEW_BY_NAME, RETRY_INTERVAL_IN_SECONDS_VIEW_BY_NAME);
        final String mainReportId = retryManager.executeCommand(retry,
            retryContext -> {
                logger.info("Attempting to retrieve mainReportId for report:" + reportName);
                return executeViewByName(url, reportName);
            });
        return mainReportId;
    }

    /**
     * Gets the {@link Report} generated by NHC.
     *
     * @param viewByldUrl
     *            The internal URL of NHC
     * @return the generated {@link Report}
     */
    public Report getMainReport(final String viewByldUrl) {
        final RetryManager retryManager = new RetryManagerBean();
        final RetryPolicy retry = getRetryPolicy(MAX_RETRIES_VIEW_BY_ID, RETRY_INTERVAL_IN_SECONDS_VIEW_BY_ID);
        final Report report = retryManager.executeCommand(retry,
            retryContext -> {
                logger.info("Attempting to retrieve Report by mainReportId");
                return executeViewById(viewByldUrl);
            });
        return report;
    }

    /**
     * Get the details of a health check profile from NHC.
     *
     * @param profileName
     *            the name of the Health Check Profile
     * @return the profile details {@link ProfileDetails}
     */
    public ProfileDetails getProfileDetails(final String profileName) {
        final RetryManager retryManager = new RetryManagerBean();
        final RetryPolicy retry = getRetryPolicy(MAX_RETRIES_VIEW_BY_NAME, RETRY_INTERVAL_IN_SECONDS_VIEW_BY_NAME);
        return retryManager.executeCommand(retry,
            retryContext -> {
                logger.info("Getting details of the health check profile {} ", profileName);
                return executeGetProfileDetails(profileName);
            });
    }

    private HttpEntity buildCreateRequest(final String nodeName, final String profileName) throws JsonProcessingException {
        final String reportName = generateReportName();
        logger.info("Creating Health Check Report for node {} with report name {}", nodeName, reportName);
        final List<String> profileNames = Arrays.asList(profileName);
        final List<String> nodeNames = Arrays.asList(nodeName);
        final CreateReportRequest request = new CreateReportRequest(reportName, profileNames, nodeNames, IMMEDIATE);
        final List<CreateReportRequest> createRequest = Arrays.asList(request);
        final String requestBody = objectMapper.writeValueAsString(createRequest);
        final EntityBuilder entityBuilder = EntityBuilder.create();
        entityBuilder.setContentType(ContentType.APPLICATION_JSON);
        entityBuilder.setText(requestBody);
        return entityBuilder.build();
    }

    private String executeViewByName(final String viewByNameUrl, final String reportName)
        throws URISyntaxException, ClientProtocolException, IOException {
        final URIBuilder builder = new URIBuilder(viewByNameUrl);
        builder.setParameter(HttpConstants.NAME, reportName);
        final HttpGet httpGet = new HttpGet(builder.build());
        httpGet.setHeader(HttpConstants.ACCEPT_HEADER, ContentType.APPLICATION_JSON.toString());
        httpGet.setHeader(HttpConstants.HOST, NHC_SERVICE.getHost());
        httpGet.setHeader(HttpConstants.USERNAME_HEADER, accessControl.getAuthUserSubject().getSubjectId());
        final HttpResponse response = httpClient.execute(httpGet);
        return responseHandler.processViewByNameResponse(response);
    }

    private Report executeViewById(final String viewByIdUrl) throws ClientProtocolException, IOException {
        final HttpGet httpGet = new HttpGet(viewByIdUrl);
        httpGet.setHeader(HttpConstants.ACCEPT_HEADER, ContentType.APPLICATION_JSON.toString());
        httpGet.setHeader(HttpConstants.HOST, NHC_SERVICE.getHost());
        httpGet.setHeader(HttpConstants.USERNAME_HEADER, accessControl.getAuthUserSubject().getSubjectId());
        final HttpResponse httpResponse = httpClient.execute(httpGet);
        return responseHandler.handleViewByIdResponse(httpResponse);
    }

    private ProfileDetails executeGetProfileDetails(final String profileName) throws URISyntaxException, IOException {
        final URIBuilder builder = new URIBuilder(NHC_PROFILE_SERVICE.getFullUrl() + profileName);
        final HttpGet httpGet = new HttpGet(builder.build());
        httpGet.setHeader(HttpConstants.ACCEPT_HEADER, ContentType.APPLICATION_JSON.toString());
        httpGet.setHeader(HttpConstants.HOST, NHC_PROFILE_SERVICE.getHost());
        httpGet.setHeader(HttpConstants.USERNAME_HEADER, accessControl.getAuthUserSubject().getSubjectId());
        final HttpResponse response = httpClient.execute(httpGet);
        return responseHandler.handleGetProfileDetailsResponse(response);
    }

    private String generateReportName() {
        final DateTimeFormatter dtf = DateTimeFormatter.ofPattern("ddMMyyyyHHmmssSSS");
        final LocalDateTime now = LocalDateTime.now();
        return new StringBuilder()
            .append("AutoProvisioning_")
            .append(dtf.format(now))
            .toString();
    }

    private String generateReport(final String nodeName, final String profileName)
        throws JsonProcessingException, IOException, ClientProtocolException, JsonParseException, JsonMappingException {
        final HttpEntity createRequest = buildCreateRequest(nodeName, profileName);
        final HttpPost post = new HttpPost(NHC_SERVICE.getFullUrl());
        post.setEntity(createRequest);
        post.setHeader(HttpConstants.USERNAME_HEADER, accessControl.getAuthUserSubject().getSubjectId());
        post.setHeader(HttpConstants.HOST, NHC_SERVICE.getHost());
        post.setHeader(HttpConstants.CONTENT_TYPE_HEADER, ContentType.APPLICATION_JSON.toString());
        post.setHeader(HttpConstants.ACCEPT_HEADER, ContentType.APPLICATION_JSON.toString());
        final HttpResponse response = httpClient.execute(post);
        return responseHandler.processCreateResponse(response);
    }

    private static RetryPolicy getRetryPolicy(final Integer retries, final Integer interval) {
        return RetryPolicy.builder()
            .attempts(retries)
            .waitInterval(interval, TimeUnit.SECONDS)
            .retryOn(HealthCheckRestServiceException.class)
            .build();
    }
}
